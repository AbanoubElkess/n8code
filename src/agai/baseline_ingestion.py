from __future__ import annotations

import hashlib
import json
from pathlib import Path
from typing import Any


class ExternalBaselineIngestionService:
    def __init__(self, registry_path: str = "config/frontier_baselines.json") -> None:
        self.registry_path = Path(registry_path)

    def ingest_file(self, input_path: str) -> dict[str, Any]:
        path = Path(input_path)
        if not path.exists():
            return {
                "status": "error",
                "reason": f"input file not found: {path}",
                "registry_path": str(self.registry_path),
                "warnings": [],
            }
        raw = path.read_text(encoding="utf-8")
        input_hash = "sha256:" + hashlib.sha256(raw.encode("utf-8")).hexdigest()
        try:
            payload = json.loads(raw)
        except json.JSONDecodeError as exc:
            return {
                "status": "error",
                "reason": f"invalid json: {exc}",
                "registry_path": str(self.registry_path),
                "input_hash": input_hash,
                "warnings": [],
            }
        return self.ingest_payload(payload=payload, input_hash=input_hash)

    def ingest_payload(self, payload: dict[str, Any], input_hash: str = "") -> dict[str, Any]:
        errors = self._validate_payload(payload)
        if errors:
            return {
                "status": "error",
                "reason": "validation failed",
                "errors": errors,
                "registry_path": str(self.registry_path),
                "input_hash": input_hash,
                "warnings": [],
            }

        warnings: list[str] = []
        normalized = self._normalize_payload(payload=payload, input_hash=input_hash, warnings=warnings)
        registry = self._load_registry()
        baselines = registry.get("baselines", [])
        if not isinstance(baselines, list):
            baselines = []

        baseline_id = str(normalized["baseline_id"])
        action = "created"
        updated: list[dict[str, Any]] = []
        replaced = False
        for item in baselines:
            if str(item.get("baseline_id", "")) == baseline_id:
                updated.append(normalized)
                replaced = True
            else:
                updated.append(item)
        if replaced:
            action = "updated"
        else:
            updated.append(normalized)
        updated.sort(key=lambda row: str(row.get("baseline_id", "")))

        registry["baselines"] = updated
        if "registry_version" not in registry:
            registry["registry_version"] = "unspecified"
        self.registry_path.parent.mkdir(parents=True, exist_ok=True)
        self.registry_path.write_text(json.dumps(registry, indent=2, ensure_ascii=True), encoding="utf-8")
        return {
            "status": "ok",
            "action": action,
            "baseline_id": baseline_id,
            "source_type": str(normalized["source_type"]),
            "verified_effective": bool(normalized["verified"]),
            "replication_status": str(normalized["evidence"]["replication_status"]),
            "registry_path": str(self.registry_path),
            "input_hash": input_hash,
            "warnings": warnings,
        }

    def _load_registry(self) -> dict[str, Any]:
        default_payload: dict[str, Any] = {
            "registry_version": "unspecified",
            "notes": "Baseline registry generated by ingestion service.",
            "baselines": [],
        }
        if not self.registry_path.exists():
            return default_payload
        try:
            payload = json.loads(self.registry_path.read_text(encoding="utf-8"))
            if not isinstance(payload, dict):
                return default_payload
            if "baselines" not in payload or not isinstance(payload.get("baselines"), list):
                payload["baselines"] = []
            return payload
        except Exception:  # noqa: BLE001
            return default_payload

    def _validate_payload(self, payload: Any) -> list[str]:
        errors: list[str] = []
        if not isinstance(payload, dict):
            return ["payload must be a json object"]

        required_fields = [
            "baseline_id",
            "label",
            "source_type",
            "source",
            "source_date",
            "suite_id",
            "scoring_protocol",
            "evidence",
            "metrics",
        ]
        for field in required_fields:
            if field not in payload:
                errors.append(f"missing field: {field}")

        source_type = str(payload.get("source_type", "")).lower()
        if source_type and not source_type.startswith("external"):
            errors.append("source_type must start with 'external' for external ingestion")

        evidence = payload.get("evidence", {})
        if not isinstance(evidence, dict):
            errors.append("evidence must be an object")
        else:
            evidence_fields = ["citation", "retrieval_date", "verification_method"]
            for field in evidence_fields:
                if not str(evidence.get(field, "")).strip():
                    errors.append(f"evidence.{field} is required")

        metrics = payload.get("metrics", {})
        if not isinstance(metrics, dict):
            errors.append("metrics must be an object")
        else:
            for key, value in metrics.items():
                try:
                    float(value)
                except (TypeError, ValueError):
                    errors.append(f"metrics.{key} must be numeric")
        return errors

    def _normalize_payload(self, payload: dict[str, Any], input_hash: str, warnings: list[str]) -> dict[str, Any]:
        evidence = dict(payload.get("evidence", {}))
        artifact_hash = str(evidence.get("artifact_hash", "")).strip()
        if not artifact_hash:
            if input_hash:
                evidence["artifact_hash"] = input_hash
                warnings.append("artifact_hash was missing and has been populated from input file hash")
            else:
                evidence["artifact_hash"] = "sha256:missing-input-hash"
                warnings.append("artifact_hash missing and no input hash available")
        replication_status = str(evidence.get("replication_status", "pending")).strip() or "pending"
        evidence["replication_status"] = replication_status

        verified_input = bool(payload.get("verified", False))
        verified_effective = verified_input
        if replication_status != "replicated-internal-harness":
            if verified_input:
                warnings.append("verified flag downgraded: replication_status is not replicated-internal-harness")
            verified_effective = False

        normalized_metrics: dict[str, float] = {}
        for key, value in dict(payload.get("metrics", {})).items():
            normalized_metrics[str(key)] = float(value)

        return {
            "baseline_id": str(payload["baseline_id"]),
            "label": str(payload["label"]),
            "source_type": str(payload["source_type"]),
            "source": str(payload["source"]),
            "source_date": str(payload["source_date"]),
            "verified": verified_effective,
            "enabled": bool(payload.get("enabled", True)),
            "suite_id": str(payload["suite_id"]),
            "scoring_protocol": str(payload["scoring_protocol"]),
            "evidence": evidence,
            "metrics": normalized_metrics,
            "notes": str(payload.get("notes", "")),
        }
